# Markov
Программа для генерации текста на основе другого при помощи цепей Маркова. Учебное задание.

# How-to build

# Цели
 * Написать на чистом C, стараясь использовать оптимиальные алгоритмы.
 * Высокая скорость, однако так как это всё же учебный проект, то без фанатизма.
 * Написать по всем правилам, т.е. соблюдая Coding Style, в едином стиле, желатьно с тестами, но опять же без фанатизма.
 * Желательно сделать метрики для оценок различных ф-ий кеширования и эффективности алгоритмов.
 * Just for fun =)

# Принцип
Читаем текст на входе, заполняем табличку вида
    <prefix> | <suffix1>, <suffix2>, ...
Где `prefix` - набор из K (обычно K = 2) идущих подряд слов в тексте,
а `suffix` - слово, идущее в тексте за префиксом.

На основе её и рандома генерим какой-нибудь бессмысленный текст.

# Используются
 * [Куку-хеш](https://en.wikipedia.org/wiki/Cuckoo_hashing) - для сопоставления слов числам и префиксов возможным суффиксам.
 * Обычное хеширование - для сопоставления слов числам.
 * Хеш функцииии для чисел.
 * Умные динамические массивы на C (добавление N элементов суммарно за O(N), а не за O(N^2))

# Хеш-функции

## Обозначения
 * `m` - какое-то достаточно большое простое число
 * `n` - размер хеш таблицы

## Для хранения хешей в хеш-таблице
 1. `(x % m) % n`
 2. что-нибудь ещё, более оригинальное

## Хеш 4х чисел
Ну если первые 4 числа генерируются достаточно хорошими хеш-функциями и независимы от друг друга,
то почему бы просто не отксорить вместе все эти 4 числа.

## Универсальное хеширование
    H(x1,...,x_k) = ((a1*x1+a2*x2+...+a_k*x_k) mod p) mod m.
где `m` - размер таблицы,
`p >> m` - простое число,
`a1, ... ,a_k` - случайные числа от `0..p-1`.

Коллизии в этом случае будут определяться уже не самими ключами, а распределением случайных чисел `a1..a_k`,
так что получится в среднем хорошее равномерное хеширование.

# Эффективные динамические массивы на C
Можно использовать ф-ию [realloc()](http://www.cplusplus.com/reference/clibrary/cstdlib/realloc/), но она медленная,
так что не стоит вызывать её слишком часто. Поэтому пусть длина нашего массива всегда равняется степени 2-ки, либо нулю.
И соответственно увеличивать и уменьшать реальную длину будем только в 2 раза, когда места будет нехватать.
Единственное о чём нужно заботиться - это об отдельных переменных для количества элемнтов в массиве и для его реального размера.

## ссылки
 * <http://en.wikipedia.org/wiki/Jenkins_hash_function>
 * <http://algolist.manual.ru/ds/s_has.php>
 
# TODO
 * А что будет, если применить этот принцип к музыке, к картинкам, etc..?
   [что-то подобное было на хабре](http://habrahabr.ru/blogs/algorithm/69985/)
